{
  "hash": "45f72c98554f7be2e993b1cb30a37eb1",
  "result": {
    "markdown": "---\ntitle: \"Merging multiple datasets with joins using `dplyr` in R\"\nsubtitle: Concepts with Examples\nauthor: Raju Rimal\ndate: 2025-03-18\n---\n\n\n<style>\n.knitsql-table {\n  overflow-x: scroll;\n}\n</style>\n\nThis post breaks down the fundamental concepts of joins when merging multiple tables/ data frames using `dplyr` package in R. I have discussed how keys connect tables and what happens to unmatched rows. In addition, I have included some edge cases such as missing values, creating intermediate variables (pre-processing) before making a join, and using multiple keys. I have tried to include SQL parallels for each types of joins I have discussed here which will make this post equally useful for database users. In order for reader to follow along, I have also created a example (dummy) dataset.\n\n## Example dataset\n\n::: panel-tabset\n\n### R\n\n\n\n\n\n::: panel-tabset\n\n#### Employee table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Employees: \n#> emp_id 3 has NA dept_id; \n#> emp_id 5's dept_id (4) is missing\nemployees <- tibble(\n  emp_id = c(1, 2, 3, 4, 5, 6),\n  first_name = c(\n    \"Alice Susanna\", \"Bob\", \"Mary Anne\", \n    \"Diana\", \"Eve\", \"Frank\"\n  ),\n  last_name = c(\n    \"Smith\", \"Johnson\", \"Brown\", \n    \"Lee\", \"Davis\", \"DeVito Jr.\"\n  ),\n  dept_id = c(1, 2, NA, 3, 4, 2),\n  salary = c(\n    60000, 75000, 80000, \n    90000, 65000, 70000\n  )\n)\n\nprint(employees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  emp_id first_name    last_name  dept_id salary\n   <dbl> <chr>         <chr>        <dbl>  <dbl>\n1      1 Alice Susanna Smith            1  60000\n2      2 Bob           Johnson          2  75000\n3      3 Mary Anne     Brown           NA  80000\n4      4 Diana         Lee              3  90000\n5      5 Eve           Davis            4  65000\n6      6 Frank         DeVito Jr.       2  70000\n```\n:::\n:::\n\n\n#### Department Table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Departments: \n#> - dept_id 5 has no employees\n#> - dept_id 2 appears once\ndepartments <- tibble(\n  dept_id = c(1, 2, 3, 5),\n  dept_name = c(\n    \"HR\", \"Engineering\", \"Marketing\", \"Finance\"\n  ),\n  manager_first = c(\n    \"alice\", \"robert\", \"diana\", \"carol\"\n  ),\n  manager_last = c(\n    \"smith\", \"johnson\", \"lee\", \"taylor\"\n  ),\n  budget = c(\n    500000, 1000000, 750000, 600000\n  )\n)\n\nprint(departments)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  dept_id dept_name   manager_first manager_last  budget\n    <dbl> <chr>       <chr>         <chr>          <dbl>\n1       1 HR          alice         smith         500000\n2       2 Engineering robert        johnson      1000000\n3       3 Marketing   diana         lee           750000\n4       5 Finance     carol         taylor        600000\n```\n:::\n:::\n\n\n:::\n\n### SQL\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RSQLite)\nlibrary(DBI)\ncon <- DBI::dbConnect(SQLite(), \"database.db\")\nif (!RSQLite::dbExistsTable(con, \"departments\")) {\n  dbWriteTable(con, name = \"departments\", value = departments)\n}\nif (!RSQLite::dbExistsTable(con, \"employees\")) {\n  dbWriteTable(con, name = \"employees\", value = employees)\n}\n```\n:::\n\n::: {.cell}\n\n```{.sql .cell-code}\nPRAGMA table_info(employees);\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 5 records\n\n|cid |name       |type | notnull|dflt_value | pk|\n|:---|:----------|:----|-------:|:----------|--:|\n|0   |emp_id     |REAL |       0|NA         |  0|\n|1   |first_name |TEXT |       0|NA         |  0|\n|2   |last_name  |TEXT |       0|NA         |  0|\n|3   |dept_id    |REAL |       0|NA         |  0|\n|4   |salary     |REAL |       0|NA         |  0|\n\n</div>\n:::\n\n::: {.cell}\n\n```{.sql .cell-code}\nPRAGMA table_info(departments);\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 5 records\n\n|cid |name          |type | notnull|dflt_value | pk|\n|:---|:-------------|:----|-------:|:----------|--:|\n|0   |dept_id       |REAL |       0|NA         |  0|\n|1   |dept_name     |TEXT |       0|NA         |  0|\n|2   |manager_first |TEXT |       0|NA         |  0|\n|3   |manager_last  |TEXT |       0|NA         |  0|\n|4   |budget        |REAL |       0|NA         |  0|\n\n</div>\n:::\n\n\n:::\n\n## Mutating Joins\n\nMutating joins combine columns from two tables based on matching keys, preserving rows depending on the join type.\n\n### Inner Join | `inner_join()`\n\n::: {.columns}\n::: {.column width=\"60%\"}\nWe can use `inner_join()` function from `dplyr` to inner join the data. Inner join retains _only rows with matching keys in both tables_. The output table contains all columns, excluding the unmatched rows from both tables.\n:::\n::: {.column width=\"40%\"}\n\n![](images/inner-join.svg){width=\"90%\"}\n\n:::\n:::\n\n::: panel-tabset\n\n##### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemployees %>% \n  inner_join(departments, by = \"dept_id\") %>% \n  select(emp_id, first_name, last_name, salary, dept_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  emp_id first_name    last_name  salary dept_name  \n   <dbl> <chr>         <chr>       <dbl> <chr>      \n1      1 Alice Susanna Smith       60000 HR         \n2      2 Bob           Johnson     75000 Engineering\n3      4 Diana         Lee         90000 Marketing  \n4      6 Frank         DeVito Jr.  70000 Engineering\n```\n:::\n:::\n\n\n##### SQL\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT\n emp.emp_id,\n emp.first_name,\n emp.last_name,\n emp.salary,\n dept.dept_name \n FROM employees AS emp\n  INNER JOIN departments as dept\n    ON emp.dept_id = dept.dept_id;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 4 records\n\n| emp_id|first_name    |last_name  | salary|dept_name   |\n|------:|:-------------|:----------|------:|:-----------|\n|      1|Alice Susanna |Smith      |  60000|HR          |\n|      2|Bob           |Johnson    |  75000|Engineering |\n|      4|Diana         |Lee        |  90000|Marketing   |\n|      6|Frank         |DeVito Jr. |  70000|Engineering |\n\n</div>\n:::\n\n\n:::\n\n\nHere,\n\n- Rows with `dept_id = NA` (Charlie) and `dept_id = 4` (Eve) were dropped (no match in `departments`).\n- `dept_id = 5` (Finance) was dropped (no match in `employees`).\n- `dept_id = 2` appears twice (Bob and Frank), causing **row expansion**.\n\n\n### Left Join | `left_join()`\n\n::: {.columns}\n::: {.column width=\"60%\"}\nLeft Join Keeps _all rows from the left table_, adding matched columns from the right table. The unmatched rows from the left table get `NA` for right-table columns. The left table is preserved entirely and the right table is _attached_ where possible.\n\n:::\n::: {.column width=\"40%\"}\n![](images/left-join.svg){width=\"90%\"}\n:::\n:::\n\n::: panel-tabset\n\n##### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemployees |> \n  left_join(departments, by = \"dept_id\") |> \n  select(names(employees), dept_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  emp_id first_name    last_name  dept_id salary dept_name  \n   <dbl> <chr>         <chr>        <dbl>  <dbl> <chr>      \n1      1 Alice Susanna Smith            1  60000 HR         \n2      2 Bob           Johnson          2  75000 Engineering\n3      3 Mary Anne     Brown           NA  80000 <NA>       \n4      4 Diana         Lee              3  90000 Marketing  \n5      5 Eve           Davis            4  65000 <NA>       \n6      6 Frank         DeVito Jr.       2  70000 Engineering\n```\n:::\n:::\n\n\n##### SQL\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  emp.*, dept.dept_name\n  FROM employees AS emp\n  LEFT JOIN departments  AS dept\n    ON emp.dept_id = dept.dept_id;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 6 records\n\n|emp_id |first_name    |last_name  | dept_id| salary|dept_name   |\n|:------|:-------------|:----------|-------:|------:|:-----------|\n|1      |Alice Susanna |Smith      |       1|  60000|HR          |\n|2      |Bob           |Johnson    |       2|  75000|Engineering |\n|3      |Mary Anne     |Brown      |      NA|  80000|NA          |\n|4      |Diana         |Lee        |       3|  90000|Marketing   |\n|5      |Eve           |Davis      |       4|  65000|NA          |\n|6      |Frank         |DeVito Jr. |       2|  70000|Engineering |\n\n</div>\n:::\n\n\n:::\n\nhere,\n\n- All employees are retained, even those with `NA` or unmatched `dept_id`.\n- `dept_id = 4` (Eve) and `NA` (Charlie) have `NA` for department columns.\n\n### Right Join | `right_join()`\n\n::: {.columns}\n::: {.column width=\"60%\"}\nSimilar to Left Join, Right join Keeps _all rows from the right table_, adding matched columns from the left table. The unmatched rows from the right table get `NA` for left-table columns. The right table is preserved entirely and the left table is _attached_ where possible.\n:::\n::: {.column width=\"40%\"}\n![](images/right-join.svg){width=\"90%\"}\n:::\n:::\n\n\n::: panel-tabset\n\n##### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemployees |> \n  right_join(departments, by = \"dept_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 9\n  emp_id first_name    last_name  dept_id salary dept_name   manager_first\n   <dbl> <chr>         <chr>        <dbl>  <dbl> <chr>       <chr>        \n1      1 Alice Susanna Smith            1  60000 HR          alice        \n2      2 Bob           Johnson          2  75000 Engineering robert       \n3      4 Diana         Lee              3  90000 Marketing   diana        \n4      6 Frank         DeVito Jr.       2  70000 Engineering robert       \n5     NA <NA>          <NA>             5     NA Finance     carol        \n# ℹ 2 more variables: manager_last <chr>, budget <dbl>\n```\n:::\n:::\n\n\n##### SQL\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT *\n  FROM employees AS emp\n  RIGHT JOIN departments  AS dept\n    ON emp.dept_id = dept.dept_id;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 5 records\n\n| emp_id|first_name    |last_name  | dept_id| salary| dept_id|dept_name   |manager_first |manager_last |  budget|\n|------:|:-------------|:----------|-------:|------:|-------:|:-----------|:-------------|:------------|-------:|\n|      1|Alice Susanna |Smith      |       1|  60000|       1|HR          |alice         |smith        |  500000|\n|      2|Bob           |Johnson    |       2|  75000|       2|Engineering |robert        |johnson      | 1000000|\n|      4|Diana         |Lee        |       3|  90000|       3|Marketing   |diana         |lee          |  750000|\n|      6|Frank         |DeVito Jr. |       2|  70000|       2|Engineering |robert        |johnson      | 1000000|\n|     NA|NA            |NA         |      NA|     NA|       5|Finance     |carol         |taylor       |  600000|\n\n</div>\n:::\n\n\n:::\n\nhere,\n\n- All departments are retained, even those with unmatched `dept_id`. The corresponding `emp_id` was set to NA if not matched with items in the departments.\n- `dept_id = 5` (Finance department) where carol is the manager is retained even if she des not have any matched records in employees table.\n\n\n###  Full Join | `full_join()`\n\n::: {.columns}\n::: {.column width=\"60%\"}\nFull join keeps _all rows from both tables_, filling `NA` where no match exists. Output is the union of both tables, with missing values for unmatched rows. In other words, it combines all data preserving everything.\n:::\n::: {.column width=\"40%\"}\n![](images/outer-join.svg){width=\"90%\"}\n:::\n:::\n\n::: panel-tabset\n\n##### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemployees %>% \n    full_join(departments, by = \"dept_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 9\n  emp_id first_name    last_name  dept_id salary dept_name   manager_first\n   <dbl> <chr>         <chr>        <dbl>  <dbl> <chr>       <chr>        \n1      1 Alice Susanna Smith            1  60000 HR          alice        \n2      2 Bob           Johnson          2  75000 Engineering robert       \n3      3 Mary Anne     Brown           NA  80000 <NA>        <NA>         \n4      4 Diana         Lee              3  90000 Marketing   diana        \n5      5 Eve           Davis            4  65000 <NA>        <NA>         \n6      6 Frank         DeVito Jr.       2  70000 Engineering robert       \n7     NA <NA>          <NA>             5     NA Finance     carol        \n# ℹ 2 more variables: manager_last <chr>, budget <dbl>\n```\n:::\n:::\n\n\n##### SQL\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT * \nFROM employees \nFULL OUTER JOIN departments \n    ON employees.dept_id = departments.dept_id;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 7 records\n\n| emp_id|first_name    |last_name  | dept_id| salary| dept_id|dept_name   |manager_first |manager_last |  budget|\n|------:|:-------------|:----------|-------:|------:|-------:|:-----------|:-------------|:------------|-------:|\n|      1|Alice Susanna |Smith      |       1|  60000|       1|HR          |alice         |smith        |  500000|\n|      2|Bob           |Johnson    |       2|  75000|       2|Engineering |robert        |johnson      | 1000000|\n|      3|Mary Anne     |Brown      |      NA|  80000|      NA|NA          |NA            |NA           |      NA|\n|      4|Diana         |Lee        |       3|  90000|       3|Marketing   |diana         |lee          |  750000|\n|      5|Eve           |Davis      |       4|  65000|      NA|NA          |NA            |NA           |      NA|\n|      6|Frank         |DeVito Jr. |       2|  70000|       2|Engineering |robert        |johnson      | 1000000|\n|     NA|NA            |NA         |      NA|     NA|       5|Finance     |carol         |taylor       |  600000|\n\n</div>\n:::\n\n\n:::\n\nhere,\n\n- Includes all employees **and** all departments, even unmatched ones.\n- `dept_id = 5` (Finance) appears with `NA` for employee columns.\n\n## Filtering Joins\n\nFiltering joins subset rows from one table based on another, without merging columns.\n\n### Semi-Join | `semi_join()`\n\n::: {.columns}\n::: {.column}\nSemi-Join Returns rows from the left table _that have a match in the right table_. It returns a subset of the left table but no columns from the right table are added. For example: filtering the employees who belongs to one of the department in the `departments` table based on their `dept_id` information.\n:::\n::: {.column}\n![](images/semi-join.svg){width=90%}\n:::\n:::\n\n::: panel-tabset\n\n#### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemployees %>% \n  semi_join(departments, by = \"dept_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  emp_id first_name    last_name  dept_id salary\n   <dbl> <chr>         <chr>        <dbl>  <dbl>\n1      1 Alice Susanna Smith            1  60000\n2      2 Bob           Johnson          2  75000\n3      4 Diana         Lee              3  90000\n4      6 Frank         DeVito Jr.       2  70000\n```\n:::\n:::\n\n\n#### SQL\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT employees.* \nFROM employees \nWHERE EXISTS (\n  SELECT 1 FROM departments \n  WHERE employees.dept_id = departments.dept_id\n);\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 4 records\n\n| emp_id|first_name    |last_name  | dept_id| salary|\n|------:|:-------------|:----------|-------:|------:|\n|      1|Alice Susanna |Smith      |       1|  60000|\n|      2|Bob           |Johnson    |       2|  75000|\n|      4|Diana         |Lee        |       3|  90000|\n|      6|Frank         |DeVito Jr. |       2|  70000|\n\n</div>\n:::\n\n\n:::\n\nhere,\n\n- Keeps only employees with `dept_id` present in `departments`.\n- Drops `emp_id=3` (`NA`) and `emp_id=5` (unmatched `dept_id=4`).\n\n### Anti-Join | `anti_join()`\n\n::: {.columns}\n::: {.column width=\"60%\"}\nAnti-Join returns rows from the left table _with no match in the right table_. For example: filtering the employees who do not belong to any of the department in the `departments` table.\n:::\n::: {.column width=\"40%\"}\n![](images/anti-join.svg){width=90%}\n:::\n:::\n\n\n::: panel-tabset\n\n\n#### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemployees %>% \n  anti_join(departments, by = \"dept_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  emp_id first_name last_name dept_id salary\n   <dbl> <chr>      <chr>       <dbl>  <dbl>\n1      3 Mary Anne  Brown          NA  80000\n2      5 Eve        Davis           4  65000\n```\n:::\n:::\n\n\n#### SQL\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT employees.* \nFROM employees \nWHERE NOT EXISTS (\n  SELECT 1 FROM departments \n  WHERE employees.dept_id = departments.dept_id\n);\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 2 records\n\n| emp_id|first_name |last_name | dept_id| salary|\n|------:|:----------|:---------|-------:|------:|\n|      3|Mary Anne  |Brown     |      NA|  80000|\n|      5|Eve        |Davis     |       4|  65000|\n\n</div>\n:::\n\n\n:::\n\nhere, only employees with `dept_id` not in `departments` (or `NA`) are kept.\n\n### Advanced Scenarios: Name Parsing and Multi-Key Joins\n\nSuppose we need find the employees with their departments who are also manager in their department. Here we have two issues to deal with:\n\na) We need multiple keys (fields/ variables) to join. For example: `dept_id` in both table and `first_name`/ `last_name` from employees table and `manager_first`/ `manager_last` from departments table.\n\n    > To solve this we can use multiple keys to join the tables. We can use semi-join or inner-join on employees table using department tables.\n\nb) The `first_name` and `last_name` from employees table has uppercase characters and middle name in `first_name` field while `manager_first` and `manager_last` from departments tables are all lowercase. We need to preprocess them before using them as a joining key.\n\n    > To solve this, we lowercase the first word from `first_name` and `manager_first` and the last word from `last_name` and `manager_last` from tables employees and departments respectively.\n\n::: panel-tabset\n\n#### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemployees |> \n  mutate(\n    fname = stringr::word(first_name, 1) |> tolower(),\n    lname = stringr::word(last_name, -1) |> tolower()\n  ) |> inner_join(\n    departments |> mutate(\n      fname = stringr::word(manager_first, 1) |> tolower(),\n      lname = stringr::word(manager_last, -1) |> tolower()\n    ) |> select(dept_name, fname, lname, dept_id),\n    by = join_by('fname', 'lname', 'dept_id')\n  ) |> select(-dept_id, -fname, -lname)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  emp_id first_name    last_name salary dept_name\n   <dbl> <chr>         <chr>      <dbl> <chr>    \n1      1 Alice Susanna Smith      60000 HR       \n2      4 Diana         Lee        90000 Marketing\n```\n:::\n:::\n\n\n#### SQL\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT \n  emp.emp_id, emp.first_name, emp.last_name, \n  emp.salary, dept.dept_name\nFROM employees emp\nJOIN departments dept ON emp.dept_id = dept.dept_id\nWHERE \n    -- First name: match first word\n    LOWER(SUBSTR(\n      emp.first_name, 1, \n      INSTR(emp.first_name || ' ', ' ') - 1\n    )) = \n    LOWER(SUBSTR(\n      dept.manager_first, 1, \n      INSTR(dept.manager_first || ' ', ' ') - 1\n    ))\n    \n    -- Last name: match last word\n    AND \n    LOWER(SUBSTR(\n      emp.last_name, \n      INSTR(' ' || emp.last_name, ' ') + 1\n    )) = \n    LOWER(SUBSTR(\n      dept.manager_last, \n      INSTR(' ' || dept.manager_last, ' ') + 1\n    ));\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 2 records\n\n| emp_id|first_name    |last_name | salary|dept_name |\n|------:|:-------------|:---------|------:|:---------|\n|      1|Alice Susanna |Smith     |  60000|HR        |\n|      4|Diana         |Lee       |  90000|Marketing |\n\n</div>\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}